import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import { ValuationResult, ReportRequest, ReportResponse } from '@shared/api';
import { getDatabase } from '../database/init';

export class ReportGenerator {
  private static reportsDir = path.join(process.cwd(), 'reports');

  static async ensureReportsDirectory(): Promise<void> {
    if (!fs.existsSync(this.reportsDir)) {
      fs.mkdirSync(this.reportsDir, { recursive: true });
    }
  }

  static async generateReport(
    valuationId: string, 
    userId: string, 
    format: 'pdf' | 'docx'
  ): Promise<ReportResponse> {
    try {
      await this.ensureReportsDirectory();

      const db = getDatabase();

      // Get valuation data
      const valuation = await db.get(`
        SELECT v.*, u.first_name, u.last_name, u.email 
        FROM valuations v 
        JOIN users u ON v.user_id = u.id 
        WHERE v.id = ? AND v.user_id = ?
      `, [valuationId, userId]);

      if (!valuation) {
        return {
          success: false,
          message: 'Valuation not found'
        };
      }

      const reportId = uuidv4();
      const fileName = `valuation_report_${valuation.company_name.replace(/[^a-zA-Z0-9]/g, '_')}_${reportId}.${format}`;
      const filePath = path.join(this.reportsDir, fileName);

      // Generate report content based on format
      if (format === 'pdf') {
        await this.generatePDFReport(valuation, filePath);
      } else {
        await this.generateDocxReport(valuation, filePath);
      }

      // Store report record in database
      await db.run(`
        INSERT INTO reports (id, valuation_id, user_id, format, file_path)
        VALUES (?, ?, ?, ?, ?)
      `, [reportId, valuationId, userId, format, filePath]);

      // Update valuation with report URL
      const downloadUrl = `/api/reports/download/${reportId}`;
      await db.run(`
        UPDATE valuations SET report_url = ? WHERE id = ?
      `, [downloadUrl, valuationId]);

      return {
        success: true,
        message: 'Report generated successfully',
        downloadUrl,
        reportId
      };

    } catch (error: any) {
      console.error('Report generation error:', error);
      return {
        success: false,
        message: 'Failed to generate report'
      };
    }
  }

  private static async generatePDFReport(valuation: any, filePath: string): Promise<void> {
    // Simulate PDF generation - in production, use libraries like PDFKit, Puppeteer, or jsPDF
    const reportContent = this.generateReportContent(valuation);
    
    // For demonstration, create a simple text file that simulates a PDF
    const pdfContent = `
%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
>>
endobj

4 0 obj
<<
/Length ${reportContent.length}
>>
stream
BT
/F1 12 Tf
50 750 Td
(${reportContent.replace(/\n/g, ') Tj T* (')}) Tj
ET
endstream
endobj

xref
0 5
0000000000 65535 f 
0000000015 00000 n 
0000000074 00000 n 
0000000120 00000 n 
0000000179 00000 n 
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
${300 + reportContent.length}
%%EOF
`;
    
    fs.writeFileSync(filePath, pdfContent);
  }

  private static async generateDocxReport(valuation: any, filePath: string): Promise<void> {
    // Simulate DOCX generation - in production, use libraries like docx or officegen
    const reportContent = this.generateReportContent(valuation);
    
    // For demonstration, create a simple text file
    fs.writeFileSync(filePath, reportContent);
  }

  private static generateReportContent(valuation: any): string {
    const methods = JSON.parse(valuation.methods_data);
    const date = new Date().toLocaleDateString();

    return `
BUSINESS VALUATION REPORT
Generated by ValuAI - ${date}

==================================================

EXECUTIVE SUMMARY
==================================================

Company: ${valuation.company_name}
Industry: ${valuation.industry}
Business Stage: ${valuation.stage}
Valuation Date: ${date}

ESTIMATED VALUATION
Primary Valuation: $${valuation.estimated_valuation_primary.toLocaleString()}
Valuation Range: $${valuation.estimated_valuation_min.toLocaleString()} - $${valuation.estimated_valuation_max.toLocaleString()}
Primary Method: ${valuation.primary_method}
Confidence Level: ${(valuation.confidence * 100).toFixed(1)}%

==================================================

COMPANY OVERVIEW
==================================================

Business Description:
${valuation.description}

Key Metrics:
- Team Size: ${valuation.team_size} members
- Market Size: ${valuation.market_size}
- Funding Goal: $${valuation.funding_goal.toLocaleString()}
- Annual Revenue: ${valuation.revenue ? '$' + valuation.revenue.toLocaleString() : 'Pre-revenue'}
- Annual Expenses: ${valuation.expenses ? '$' + valuation.expenses.toLocaleString() : 'Not disclosed'}

==================================================

VALUATION METHODOLOGY
==================================================

This valuation has been calculated using multiple globally recognized methodologies:

${methods.map((method: any) => `
${method.name}:
- Calculated Value: $${method.value.toLocaleString()}
- Method Confidence: ${(method.confidence * 100).toFixed(1)}%
- Weight in Analysis: ${(method.weight * 100).toFixed(1)}%
`).join('\n')}

PRIMARY VALUATION METHOD: ${valuation.primary_method}

The ${valuation.primary_method} was selected as the primary methodology based on:
- Applicability to business stage (${valuation.stage})
- Data availability and quality
- Industry best practices
- Method confidence level

==================================================

VALUATION ANALYSIS
==================================================

Market Opportunity:
The target addressable market of ${valuation.market_size} presents significant opportunity for growth and value creation.

Competitive Position:
${valuation.competition || 'The company operates in a competitive market environment.'}

Financial Performance:
${valuation.revenue ? 
  `Current annual revenue of $${valuation.revenue.toLocaleString()} demonstrates market traction.` : 
  'As a pre-revenue company, valuation is based on potential and market opportunity.'}

Team Assessment:
With ${valuation.team_size} team members, the company ${valuation.team_size >= 5 ? 'has a substantial' : valuation.team_size >= 3 ? 'has an adequate' : 'may benefit from expanding its'} team to execute on its business plan.

==================================================

FUNDING ANALYSIS
==================================================

Funding Requirement: $${valuation.funding_goal.toLocaleString()}
Use of Funds: ${valuation.use_of_funds || 'To support business growth and operations'}

Based on the primary valuation of $${valuation.estimated_valuation_primary.toLocaleString()}, 
the requested funding of $${valuation.funding_goal.toLocaleString()} would represent ${((valuation.funding_goal / valuation.estimated_valuation_primary) * 100).toFixed(1)}% 
of the company's estimated value.

==================================================

DISCLAIMERS & LIMITATIONS
==================================================

This valuation is based on information provided and standard industry methodologies. 
Actual market valuation may vary based on:

- Market conditions at time of transaction
- Investor appetite and risk tolerance
- Due diligence findings
- Negotiation dynamics
- Economic factors

This report is for informational purposes and does not constitute:
- Investment advice
- Guarantee of funding success
- Audit or verification of financial data
- Legal or tax advice

==================================================

ABOUT VALUAI
==================================================

ValuAI is an AI-powered business valuation platform that provides 
professional-grade valuations using globally accepted methodologies. 
Our platform helps entrepreneurs, investors, and advisors make 
informed decisions with standardized, credible valuation analysis.

For questions about this report, please contact support@valuai.com

Report Generated: ${date}
Report ID: ${valuation.id}
Confidential & Proprietary
`;
  }

  static async getReportFile(reportId: string, userId: string): Promise<{ filePath: string; fileName: string } | null> {
    try {
      const db = getDatabase();
      
      const report = await db.get(`
        SELECT r.*, v.company_name 
        FROM reports r 
        JOIN valuations v ON r.valuation_id = v.id 
        WHERE r.id = ? AND r.user_id = ?
      `, [reportId, userId]);

      if (!report || !fs.existsSync(report.file_path)) {
        return null;
      }

      // Increment download count
      await db.run(`
        UPDATE reports SET download_count = download_count + 1 WHERE id = ?
      `, [reportId]);

      const fileName = `${report.company_name.replace(/[^a-zA-Z0-9]/g, '_')}_valuation_report.${report.format}`;

      return {
        filePath: report.file_path,
        fileName
      };

    } catch (error) {
      console.error('Get report file error:', error);
      return null;
    }
  }

  static async getUserReports(userId: string): Promise<any[]> {
    try {
      const db = getDatabase();
      
      const reports = await db.all(`
        SELECT r.*, v.company_name, v.estimated_valuation_primary
        FROM reports r 
        JOIN valuations v ON r.valuation_id = v.id 
        WHERE r.user_id = ? 
        ORDER BY r.created_at DESC
      `, [userId]);

      return reports.map(report => ({
        id: report.id,
        valuationId: report.valuation_id,
        companyName: report.company_name,
        format: report.format,
        downloadCount: report.download_count,
        createdAt: report.created_at,
        downloadUrl: `/api/reports/download/${report.id}`
      }));

    } catch (error) {
      console.error('Get user reports error:', error);
      return [];
    }
  }
}
